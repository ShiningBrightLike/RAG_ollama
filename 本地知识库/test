1.深度交叉网络DCN手撕
"""
class CrossNet(tf.keras.layers.Layer):
    """ 交叉网络核心层 """
    def __init__(self, layer_num=3):
        super().__init__()
        self.layer_num = layer_num  # 交叉层数
    
    def build(self, input_shape):
        # 初始化各层参数：权重矩阵W和偏置b
        self.weights = [self.add_weight(shape=(input_shape[-1],1),
                        initializer='glorot_normal') for _ in range(self.layer_num)]
        self.biases = [self.add_weight(shape=(input_shape[-1],),
                      initializer='zeros') for _ in range(self.layer_num)]
    
    def call(self, x0):
        x = x0  # 初始输入
        for i in range(self.layer_num):
            # 计算交叉项：x0 * (W*x + b) + x
            x = tf.multiply(x0, tf.matmul(x, self.weights[i]) + self.biases[i]) + x
        return x

class DCN(tf.keras.Model):
    def __init__(self):
        super().__init__()
        self.embedding = tf.keras.layers.Embedding(1000, 8)  # 假设离散特征嵌入
        self.cross_net = CrossNet(layer_num=3)  # 3层交叉网络（4阶特征交叉）
        self.dnn = tf.keras.Sequential([        # 深度网络部分
            tf.keras.layers.Dense(64, activation='relu'),
            tf.keras.layers.Dense(32, activation='relu')])
        self.final_layer = tf.keras.layers.Dense(1, activation='sigmoid')
        
    def call(self, inputs):
        # 处理输入（假设输入含离散特征）
        emb = self.embedding(inputs)
        emb_flat = tf.keras.layers.Flatten()(emb)
        
        # 并行计算交叉网络和深度网络
        cross_output = self.cross_net(emb_flat)      # [B, D]
        dnn_output = self.dnn(emb_flat)              # [B, D]
        
        # 拼接后输出
        concat = tf.concat([cross_output, dnn_output], axis=1)
        return self.final_layer(concat)
"""

